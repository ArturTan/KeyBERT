{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"KeyBERT \u00b6 KeyBERT is a minimal and easy-to-use keyword extraction technique that leverages BERT embeddings to create keywords and keyphrases that are most similar to a document. About the Project \u00b6 Although that are already many methods available for keyword generation (e.g., Rake , YAKE! , TF-IDF, etc.) I wanted to create a very basic, but powerful method for extracting keywords and keyphrases. This is where KeyBERT comes in! Which uses BERT-embeddings and simple cosine similarity to find the sub-phrases in a document that are the most similar to the document itself. First, document embeddings are extracted with BERT to get a document-level representation. Then, word embeddings are extracted for N-gram words/phrases. Finally, we use cosine similarity to find the words/phrases that are the most similar to the document. The most similar words could then be identified as the words that best describe the entire document. KeyBERT is by no means unique and is created as a quick and easy method for creating keywords and keyphrases. Although there are many great papers and solutions out there that use BERT-embeddings (e.g., 1 , 2 , 3 , ), I could not find a BERT-based solution that did not have to be trained from scratch and could be used for beginners ( correct me if I'm wrong! ). Thus, the goal was a pip install keybert and at most 3 lines of code in usage. NOTE : If you use MMR to select the candidates instead of simple cosine similarity, this repo is essentially a simplified implementation of EmbedRank with BERT-embeddings. Installation \u00b6 PyTorch 1.2.0 or higher is recommended. If the install below gives an error, please install pytorch first here . Installation can be done using pypi : pip install keybert Usage \u00b6 The most minimal example can be seen below for the extraction of keywords: from keybert import KeyBERT doc = \"\"\" Supervised learning is the machine learning task of learning a function that maps an input to an output based on example input-output pairs.[1] It infers a function from labeled training data consisting of a set of training examples.[2] In supervised learning, each example is a pair consisting of an input object (typically a vector) and a desired output value (also called the supervisory signal). A supervised learning algorithm analyzes the training data and produces an inferred function, which can be used for mapping new examples. An optimal scenario will allow for the algorithm to correctly determine the class labels for unseen instances. This requires the learning algorithm to generalize from the training data to unseen situations in a 'reasonable' way (see inductive bias). \"\"\" model = KeyBERT ( 'distilbert-base-nli-mean-tokens' ) keywords = model . extract_keywords ( doc ) You can set keyphrase_length to set the length of the resulting keyphras: >>> model . extract_keywords ( doc , keyphrase_length = 1 , stop_words = None ) [ 'learning' , 'training' , 'algorithm' , 'class' , 'mapping' ] To extract keyphrases, simply set keyphrase_length to 2 or higher depending on the number of words you would like in the resulting keyphrases: >>> model . extract_keywords ( doc , keyphrase_length = 3 , stop_words = None ) [ 'learning algorithm' , 'learning machine' , 'machine learning' , 'supervised learning' , 'learning function' ] To diversify the results, we can use Maximal Margin Relevance (MMR) to create keywords / keyphrases which is also based on cosine similarity. The results with high diversity : >>> model . extract_keywords ( doc , keyphrase_length = 3 , stop_words = 'english' , use_mmr = True , diversity = 0.7 ) [ 'algorithm generalize training' , 'labels unseen instances' , 'new examples optimal' , 'determine class labels' , 'supervised learning algorithm' ] The results with low diversity : >>> model . extract_keywords ( doc , keyphrase_length = 3 , stop_words = 'english' , use_mmr = True , diversity = 0.2 ) [ 'algorithm generalize training' , 'learning machine learning' , 'learning algorithm analyzes' , 'supervised learning algorithm' , 'algorithm analyzes training' ] References \u00b6 Below, you can find several resources that were used for the creation of KeyBERT but most importantly, are amazing resources for creating impressive keyword extraction models: Papers : * Sharma, P., & Li, Y. (2019). Self-Supervised Contextual Keyword and Keyphrase Retrieval with Self-Labelling. Github Repos : https://github.com/thunlp/BERT-KPE https://github.com/ibatra/BERT-Keyword-Extractor https://github.com/pranav-ust/BERT-keyphrase-extraction https://github.com/swisscom/ai-research-keyphrase-extraction MMR : The selection of keywords/keyphrases was modelled after: * https://github.com/swisscom/ai-research-keyphrase-extraction NOTE : If you find a paper or github repo that has an easy-to-use implementation of BERT-embeddings for keyword/keyphrase extraction, let me know! I'll make sure to add it a reference to this repo.","title":"Index"},{"location":"index.html#keybert","text":"KeyBERT is a minimal and easy-to-use keyword extraction technique that leverages BERT embeddings to create keywords and keyphrases that are most similar to a document.","title":"KeyBERT"},{"location":"index.html#about-the-project","text":"Although that are already many methods available for keyword generation (e.g., Rake , YAKE! , TF-IDF, etc.) I wanted to create a very basic, but powerful method for extracting keywords and keyphrases. This is where KeyBERT comes in! Which uses BERT-embeddings and simple cosine similarity to find the sub-phrases in a document that are the most similar to the document itself. First, document embeddings are extracted with BERT to get a document-level representation. Then, word embeddings are extracted for N-gram words/phrases. Finally, we use cosine similarity to find the words/phrases that are the most similar to the document. The most similar words could then be identified as the words that best describe the entire document. KeyBERT is by no means unique and is created as a quick and easy method for creating keywords and keyphrases. Although there are many great papers and solutions out there that use BERT-embeddings (e.g., 1 , 2 , 3 , ), I could not find a BERT-based solution that did not have to be trained from scratch and could be used for beginners ( correct me if I'm wrong! ). Thus, the goal was a pip install keybert and at most 3 lines of code in usage. NOTE : If you use MMR to select the candidates instead of simple cosine similarity, this repo is essentially a simplified implementation of EmbedRank with BERT-embeddings.","title":"About the Project"},{"location":"index.html#installation","text":"PyTorch 1.2.0 or higher is recommended. If the install below gives an error, please install pytorch first here . Installation can be done using pypi : pip install keybert","title":"Installation"},{"location":"index.html#usage","text":"The most minimal example can be seen below for the extraction of keywords: from keybert import KeyBERT doc = \"\"\" Supervised learning is the machine learning task of learning a function that maps an input to an output based on example input-output pairs.[1] It infers a function from labeled training data consisting of a set of training examples.[2] In supervised learning, each example is a pair consisting of an input object (typically a vector) and a desired output value (also called the supervisory signal). A supervised learning algorithm analyzes the training data and produces an inferred function, which can be used for mapping new examples. An optimal scenario will allow for the algorithm to correctly determine the class labels for unseen instances. This requires the learning algorithm to generalize from the training data to unseen situations in a 'reasonable' way (see inductive bias). \"\"\" model = KeyBERT ( 'distilbert-base-nli-mean-tokens' ) keywords = model . extract_keywords ( doc ) You can set keyphrase_length to set the length of the resulting keyphras: >>> model . extract_keywords ( doc , keyphrase_length = 1 , stop_words = None ) [ 'learning' , 'training' , 'algorithm' , 'class' , 'mapping' ] To extract keyphrases, simply set keyphrase_length to 2 or higher depending on the number of words you would like in the resulting keyphrases: >>> model . extract_keywords ( doc , keyphrase_length = 3 , stop_words = None ) [ 'learning algorithm' , 'learning machine' , 'machine learning' , 'supervised learning' , 'learning function' ] To diversify the results, we can use Maximal Margin Relevance (MMR) to create keywords / keyphrases which is also based on cosine similarity. The results with high diversity : >>> model . extract_keywords ( doc , keyphrase_length = 3 , stop_words = 'english' , use_mmr = True , diversity = 0.7 ) [ 'algorithm generalize training' , 'labels unseen instances' , 'new examples optimal' , 'determine class labels' , 'supervised learning algorithm' ] The results with low diversity : >>> model . extract_keywords ( doc , keyphrase_length = 3 , stop_words = 'english' , use_mmr = True , diversity = 0.2 ) [ 'algorithm generalize training' , 'learning machine learning' , 'learning algorithm analyzes' , 'supervised learning algorithm' , 'algorithm analyzes training' ]","title":"Usage"},{"location":"index.html#references","text":"Below, you can find several resources that were used for the creation of KeyBERT but most importantly, are amazing resources for creating impressive keyword extraction models: Papers : * Sharma, P., & Li, Y. (2019). Self-Supervised Contextual Keyword and Keyphrase Retrieval with Self-Labelling. Github Repos : https://github.com/thunlp/BERT-KPE https://github.com/ibatra/BERT-Keyword-Extractor https://github.com/pranav-ust/BERT-keyphrase-extraction https://github.com/swisscom/ai-research-keyphrase-extraction MMR : The selection of keywords/keyphrases was modelled after: * https://github.com/swisscom/ai-research-keyphrase-extraction NOTE : If you find a paper or github repo that has an easy-to-use implementation of BERT-embeddings for keyword/keyphrase extraction, let me know! I'll make sure to add it a reference to this repo.","title":"References"},{"location":"api/keybert.html","text":"KeyBERT \u00b6 A minimal method for keyword extraction with BERT The keyword extraction is done by finding the sub-phrases in a document that are the most similar to the document itself. First, document embeddings are extracted with BERT to get a document-level representation. Then, word embeddings are extracted for N-gram words/phrases. Finally, we use cosine similarity to find the words/phrases that are the most similar to the document. The most similar words could then be identified as the words that best describe the entire document. Parameters Name Type Description Default model str the name of the model used by sentence-transformer for a full overview see https://www.sbert.net/docs/pretrained_models.html 'distilbert-base-nli-mean-tokens' extract_keywords ( self , docs , keyphrase_length = 1 , stop_words = 'english' , top_n = 5 , min_df = 1 , use_maxsum = False , use_mmr = False , diversity = 0.5 ) \u00b6 Show source code in keybert\\model.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def extract_keywords ( self , docs : Union [ str , List [ str ]], keyphrase_length : int = 1 , stop_words : Union [ str , List [ str ]] = 'english' , top_n : int = 5 , min_df : int = 1 , use_maxsum : bool = False , use_mmr : bool = False , diversity : float = 0.5 ) -> Union [ List [ str ], List [ List [ str ]]]: \"\"\" Extract keywords/keyphrases NOTE: I would advise you to iterate over single documents as they will need the least amount of memory. Even though this is slower, you are not likely to run into memory errors. Multiple Documents: There is an option to extract keywords for multiple documents that is faster than extraction for multiple single documents. However...this method assumes that you can keep the word embeddings for all words in the vocabulary in memory which might be troublesome. I would advise against using this option and simply iterating over documents instead if you have limited hardware. Arguments: docs: The document(s) for which to extract keywords/keyphrases keyphrase_length: Length, in words, of the extracted keywords/keyphrases stop_words: Stopwords to remove from the document top_n: Return the top n keywords/keyphrases min_df: Minimum document frequency of a word across all documents if keywords for multiple documents need to be extracted use_maxsum: Whether to use Max Sum Similarity for the selection of keywords/keyphrases use_mmr: Whether to use Maximal Marginal Relevance (MMR) for the selection of keywords/keyphrases diversity: The diversity of the results between 0 and 1 if use_mmr is set to True Returns: keywords: the top n keywords for a document \"\"\" if isinstance ( docs , str ): return self . _extract_keywords_single_doc ( docs , keyphrase_length , stop_words , top_n , use_maxsum , use_mmr , diversity ) elif isinstance ( docs , list ): warnings . warn ( \"Although extracting keywords for multiple documents is faster \" \"than iterating over single documents, it requires significant memory \" \"to hold all word embeddings. Use this at your own discretion!\" ) return self . _extract_keywords_multiple_docs ( docs , keyphrase_length , stop_words , top_n , min_df = min_df ) Extract keywords/keyphrases Note I would advise you to iterate over single documents as they will need the least amount of memory. Even though this is slower, you are not likely to run into memory errors. Multiple Documents: There is an option to extract keywords for multiple documents that is faster than extraction for multiple single documents. However...this method assumes that you can keep the word embeddings for all words in the vocabulary in memory which might be troublesome. I would advise against using this option and simply iterating over documents instead if you have limited hardware. Parameters Name Type Description Default docs Union[str, List[str]] The document(s) for which to extract keywords/keyphrases required keyphrase_length int Length, in words, of the extracted keywords/keyphrases 1 stop_words Union[str, List[str]] Stopwords to remove from the document 'english' top_n int Return the top n keywords/keyphrases 5 min_df int Minimum document frequency of a word across all documents if keywords for multiple documents need to be extracted 1 use_maxsum bool Whether to use Max Sum Similarity for the selection of keywords/keyphrases False use_mmr bool Whether to use Maximal Marginal Relevance (MMR) for the selection of keywords/keyphrases False diversity float The diversity of the results between 0 and 1 if use_mmr is set to True 0.5 Returns Type Description Union[List[str], List[List[str]]] keywords: the top n keywords for a document","title":"KeyBERT"},{"location":"api/keybert.html#keybert","text":"A minimal method for keyword extraction with BERT The keyword extraction is done by finding the sub-phrases in a document that are the most similar to the document itself. First, document embeddings are extracted with BERT to get a document-level representation. Then, word embeddings are extracted for N-gram words/phrases. Finally, we use cosine similarity to find the words/phrases that are the most similar to the document. The most similar words could then be identified as the words that best describe the entire document. Parameters Name Type Description Default model str the name of the model used by sentence-transformer for a full overview see https://www.sbert.net/docs/pretrained_models.html 'distilbert-base-nli-mean-tokens'","title":"KeyBERT"},{"location":"api/keybert.html#keybert.model.KeyBERT.extract_keywords","text":"Show source code in keybert\\model.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def extract_keywords ( self , docs : Union [ str , List [ str ]], keyphrase_length : int = 1 , stop_words : Union [ str , List [ str ]] = 'english' , top_n : int = 5 , min_df : int = 1 , use_maxsum : bool = False , use_mmr : bool = False , diversity : float = 0.5 ) -> Union [ List [ str ], List [ List [ str ]]]: \"\"\" Extract keywords/keyphrases NOTE: I would advise you to iterate over single documents as they will need the least amount of memory. Even though this is slower, you are not likely to run into memory errors. Multiple Documents: There is an option to extract keywords for multiple documents that is faster than extraction for multiple single documents. However...this method assumes that you can keep the word embeddings for all words in the vocabulary in memory which might be troublesome. I would advise against using this option and simply iterating over documents instead if you have limited hardware. Arguments: docs: The document(s) for which to extract keywords/keyphrases keyphrase_length: Length, in words, of the extracted keywords/keyphrases stop_words: Stopwords to remove from the document top_n: Return the top n keywords/keyphrases min_df: Minimum document frequency of a word across all documents if keywords for multiple documents need to be extracted use_maxsum: Whether to use Max Sum Similarity for the selection of keywords/keyphrases use_mmr: Whether to use Maximal Marginal Relevance (MMR) for the selection of keywords/keyphrases diversity: The diversity of the results between 0 and 1 if use_mmr is set to True Returns: keywords: the top n keywords for a document \"\"\" if isinstance ( docs , str ): return self . _extract_keywords_single_doc ( docs , keyphrase_length , stop_words , top_n , use_maxsum , use_mmr , diversity ) elif isinstance ( docs , list ): warnings . warn ( \"Although extracting keywords for multiple documents is faster \" \"than iterating over single documents, it requires significant memory \" \"to hold all word embeddings. Use this at your own discretion!\" ) return self . _extract_keywords_multiple_docs ( docs , keyphrase_length , stop_words , top_n , min_df = min_df ) Extract keywords/keyphrases Note I would advise you to iterate over single documents as they will need the least amount of memory. Even though this is slower, you are not likely to run into memory errors. Multiple Documents: There is an option to extract keywords for multiple documents that is faster than extraction for multiple single documents. However...this method assumes that you can keep the word embeddings for all words in the vocabulary in memory which might be troublesome. I would advise against using this option and simply iterating over documents instead if you have limited hardware. Parameters Name Type Description Default docs Union[str, List[str]] The document(s) for which to extract keywords/keyphrases required keyphrase_length int Length, in words, of the extracted keywords/keyphrases 1 stop_words Union[str, List[str]] Stopwords to remove from the document 'english' top_n int Return the top n keywords/keyphrases 5 min_df int Minimum document frequency of a word across all documents if keywords for multiple documents need to be extracted 1 use_maxsum bool Whether to use Max Sum Similarity for the selection of keywords/keyphrases False use_mmr bool Whether to use Maximal Marginal Relevance (MMR) for the selection of keywords/keyphrases False diversity float The diversity of the results between 0 and 1 if use_mmr is set to True 0.5 Returns Type Description Union[List[str], List[List[str]]] keywords: the top n keywords for a document","title":"extract_keywords()"},{"location":"api/maxsum.html","text":"Max Sum Similarity \u00b6 Calculate Max Sum Distance for extraction of keywords We take the 2 top_n most similar words/phrases to the document. Then, we take all top_n combinations from the 2 top_n words and extract the combination that are the least similar to each other by cosine similarity. Note This is O(n^2) and therefore not advised if you use a large top_n Parameters Name Type Description Default doc_embedding ndarray The document embeddings required word_embeddings ndarray The embeddings of the selected candidate keywords/phrases required words List[str] The selected candidate keywords/keyphrases required top_n int The number of keywords/keyhprases to return required Returns Type Description List[str] List[str]: The selected keywords/keyphrases","title":"MaxSum"},{"location":"api/maxsum.html#max-sum-similarity","text":"Calculate Max Sum Distance for extraction of keywords We take the 2 top_n most similar words/phrases to the document. Then, we take all top_n combinations from the 2 top_n words and extract the combination that are the least similar to each other by cosine similarity. Note This is O(n^2) and therefore not advised if you use a large top_n Parameters Name Type Description Default doc_embedding ndarray The document embeddings required word_embeddings ndarray The embeddings of the selected candidate keywords/phrases required words List[str] The selected candidate keywords/keyphrases required top_n int The number of keywords/keyhprases to return required Returns Type Description List[str] List[str]: The selected keywords/keyphrases","title":"Max Sum Similarity"},{"location":"api/mmr.html","text":"Maximal Marginal Relevance \u00b6 Calculate Maximal Marginal Relevance (MMR) between candidate keywords and the document. MMR considers the similarity of keywords/keyphrases with the document, along with the similarity of already selected keywords and keyphrases. This results in a selection of keywords that maximize their within diversity with respect to the document. Parameters Name Type Description Default doc_embedding ndarray The document embeddings required word_embeddings ndarray The embeddings of the selected candidate keywords/phrases required words List[str] The selected candidate keywords/keyphrases required top_n int The number of keywords/keyhprases to return 5 diversity float How diverse the select keywords/keyphrases are. Values between 0 and 1 with 0 being not diverse at all and 1 being most diverse. 0.8 Returns Type Description List[str] List[str]: The selected keywords/keyphrases","title":"MMR"},{"location":"api/mmr.html#maximal-marginal-relevance","text":"Calculate Maximal Marginal Relevance (MMR) between candidate keywords and the document. MMR considers the similarity of keywords/keyphrases with the document, along with the similarity of already selected keywords and keyphrases. This results in a selection of keywords that maximize their within diversity with respect to the document. Parameters Name Type Description Default doc_embedding ndarray The document embeddings required word_embeddings ndarray The embeddings of the selected candidate keywords/phrases required words List[str] The selected candidate keywords/keyphrases required top_n int The number of keywords/keyhprases to return 5 diversity float How diverse the select keywords/keyphrases are. Values between 0 and 1 with 0 being not diverse at all and 1 being most diverse. 0.8 Returns Type Description List[str] List[str]: The selected keywords/keyphrases","title":"Maximal Marginal Relevance"}]}